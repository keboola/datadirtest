<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>datadirtest.datadirtest API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>datadirtest.datadirtest</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import filecmp
import importlib.util
import logging
import os
import shutil
import sys
import tempfile
import unittest
from importlib.abc import Loader
from os import path
from pathlib import Path
from runpy import run_path
from typing import List, Optional, Type


class TestDataDir(unittest.TestCase):
    &#34;&#34;&#34;
    A test class that runs a component script to get a real output of a component and compares the output to the
    specified expected output of that component and its configuration
    &#34;&#34;&#34;

    def __init__(self, data_dir: str, component_script: str, method_name: str = &#39;compare_source_and_expected&#39;,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;
        Args:
            method_name (str): name of the testing method to be run
            data_dir (str): file_path to directory which holds the component config, source, and expected directories
            component_script (str): file_path to component script that should be run
            context_parameters (dict): Optional context parameters injected from the DirTester runner.
        &#34;&#34;&#34;
        super(TestDataDir, self).__init__(methodName=method_name)
        self.component_script = component_script
        self.orig_dir = data_dir
        self.expected_path = path.join(data_dir, &#39;expected&#39;)
        self.context_parameters = context_parameters

    def setUp(self):
        self.data_dir = self._create_temporary_copy()
        self._run_set_up_script()

    def _run_set_up_script(self):
        start_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;set_up.py&#39;)
        if os.path.exists(start_script_path):
            script = self._load_module_at_path(start_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The set_up.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def tearDown(self) -&gt; None:
        self._run_tear_down_script()
        shutil.rmtree(self.data_dir)

    @staticmethod
    def _load_module_at_path(run_script_path):
        spec = importlib.util.spec_from_file_location(&#34;custom_scripts&#34;, run_script_path)
        script = importlib.util.module_from_spec(spec)
        assert isinstance(spec.loader, Loader)
        spec.loader.exec_module(script)
        return script

    def _run_tear_down_script(self):
        end_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;tear_down.py&#39;)
        if os.path.exists(end_script_path):
            script = self._load_module_at_path(end_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The tear_down.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def id(self):
        return path.basename(self.orig_dir)

    def shortDescription(self) -&gt; Optional[str]:
        return path.basename(self.orig_dir)

    def _create_temporary_copy(self):
        temp_dir = tempfile.gettempdir()
        dst_path = path.join(temp_dir, &#39;test_data&#39;)
        if path.exists(dst_path):
            shutil.rmtree(dst_path)

        shutil.copytree(self.orig_dir, dst_path)
        return dst_path

    def run_component(self):
        &#34;&#34;&#34;
        Runs a component script with a specified configuration
        &#34;&#34;&#34;
        source_dir = path.join(self.data_dir, &#34;source&#34;, &#34;data&#34;)
        os.environ[&#34;KBC_DATADIR&#34;] = source_dir
        run_path(self.component_script, run_name=&#39;__main__&#39;)

    def compare_source_and_expected(self):
        &#34;&#34;&#34;
        Executes and compares source and expected directories based on the nested directory structure and files
        within them

        &#34;&#34;&#34;
        logging.info(f&#34;Running {self.component_script} with configuration from {self.data_dir}&#34;)
        self.run_component()

        files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, &#39;expected&#39;)
        files_real_path, tables_real_path = self.get_data_paths(self.data_dir, &#39;source&#39;)

        if path.exists(files_expected_path) or path.exists(files_real_path):
            self.assert_directory_structure_match(files_expected_path, files_real_path)
            self.assert_directory_files_contents_match(files_expected_path, files_real_path)
        if path.exists(tables_expected_path) or path.exists(tables_real_path):
            self.assert_directory_structure_match(tables_expected_path, tables_real_path)
            self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)
        logging.info(&#34;Tests passed successfully &#34;)

    @staticmethod
    def get_data_paths(data_dir: str, dir_type: str):
        &#34;&#34;&#34;
        Uses the Keboola data structure to return paths to files and tables

        Args:
            data_dir: file_path of directory to get file and table paths from
            dir_type: type of directory source or expected

        Returns:
            paths to files and tables
        &#34;&#34;&#34;
        files_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;files&#39;)
        tables_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;tables&#39;)
        return files_expected_path, tables_expected_path

    @staticmethod
    def get_all_files_in_dir(dir_path: str):
        &#34;&#34;&#34;
        Gets all non-hidden files from a directory and its subdirectory

        Args:
            dir_path: file_path of directory to fetch files from

        Returns:
            list of files in the directory
        &#34;&#34;&#34;
        files = []
        for sub_dir, dir_names, file_names in os.walk(dir_path):
            for filename in [f for f in file_names if not f.startswith(&#34;.&#34;)]:
                files.append(os.path.join(sub_dir, filename))
        return files

    def assert_directory_structure_match(self, expected_path: str, real_path: str):
        &#34;&#34;&#34;
        Tests whether directory structures of two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            expected_path: Path holding the directory of expected files
            real_path: Path holding the directory of real/source files
        &#34;&#34;&#34;
        compared_dir = filecmp.dircmp(expected_path, real_path)

        left = [file for file in compared_dir.left_only if not file.startswith(&#39;.&#39;)]
        right = [file for file in compared_dir.right_only if not file.startswith(&#39;.&#39;)]

        self.assertEqual(left, [], f&#34; Files : {left} exists only in expected output and not in actual output&#34;)
        self.assertEqual(right, [], f&#34; Files : {right} exists only in actual output and not in expected output&#34;)

    def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
        &#34;&#34;&#34;
        Tests whether files in two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            files_expected_path:  Path holding expected files
            files_real_path: Path holding real/source files
        &#34;&#34;&#34;
        file_paths = self.get_all_files_in_dir(files_expected_path)
        common_files = [file.replace(files_expected_path, &#34;&#34;).strip(&#34;/&#34;).strip(&#39;\\&#39;) for file in file_paths]
        equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
        self.assertEqual(mismatch, [], f&#34; Files : {mismatch} do not match&#34;)
        self.assertEqual(errors, [], f&#34; Files : {errors} could not be compared&#34;)


class DataDirTester:
    &#34;&#34;&#34;
        Object that executes functional tests of the Keboola Connection components.

        The `DataDirTester` looks for the `component.py` script and executes it against the specified source folders,
        the `component.py` should expect the data folder path in the environment variable `KBC_DATADIR`.

        Each test is specified by a folder containing following folder structure:

        - `source` - contains data folder that would be on the input of the component
        - `expected` - contains data folder that is result of the execution against the `source` folder.
        Include only folder that contain some files, e.g. `expected/files/out/file.json`
    &#34;&#34;&#34;

    def __init__(self, data_dir: str = Path(&#39;./tests/functional&#39;).absolute().as_posix(),
                 component_script: str = Path(&#39;./src/component.py&#39;).absolute().as_posix(),
                 test_data_dir_class: Type[TestDataDir] = TestDataDir,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;

        Args:
            data_dir (str): file_path to directory that holds functional test directories. By default this is
            ./functional
            component_script (str): file_path to the component script. By default this is ../src/component.py
            context_parameters (dict): dictionary with optional parameters that will be passed to each Test instance.
            Usefull when overriding the TestDataDirClass to add custom functionality
            test_data_dir_class (Type[TestDataDir]): Class extending datadirtest.TestDataDir class with additional
            functionality. It will be used for each test in the suit.


        &#34;&#34;&#34;
        self._data_dir = data_dir
        self._component_script = component_script
        self._context_parameters = context_parameters or {}
        self.__test_class = test_data_dir_class

    def run(self):
        &#34;&#34;&#34;
            Runs functional tests specified in the provided folder based on the source/expected datadirs.
        &#34;&#34;&#34;
        testing_dirs = self._get_testing_dirs(self._data_dir)
        dir_test_suite = self._build_dir_test_suite(testing_dirs)
        test_runner = unittest.TextTestRunner(verbosity=3)
        result = test_runner.run(dir_test_suite)
        if not result.wasSuccessful():
            raise AssertionError(f&#39;Functional test suite failed. {result.errors}&#39;)

    @staticmethod
    def _get_testing_dirs(data_dir: str) -&gt; List:
        &#34;&#34;&#34;
        Gets directories within a directory that do not start with an underscore

        Args:
            data_dir: directory which holds directories

        Returns:
            list of paths inside directory
        &#34;&#34;&#34;
        return [os.path.join(data_dir, o) for o in os.listdir(data_dir) if
                os.path.isdir(os.path.join(data_dir, o)) and not o.startswith(&#39;_&#39;)]

    def _build_dir_test_suite(self, testing_dirs):
        &#34;&#34;&#34;
        Creates a test suite for a directory, each test is added using addTest to pass through parameters

        Args:
            testing_dirs: directories that holds data for the test

        Returns:
            Unittest Suite containing all functional tests

        &#34;&#34;&#34;
        suite = unittest.TestSuite()
        for testing_dir in testing_dirs:
            suite.addTest(self.__test_class(method_name=&#39;compare_source_and_expected&#39;,
                                            data_dir=testing_dir,
                                            component_script=self._component_script,
                                            context_parameters=self._context_parameters))
        return suite


if __name__ == &#34;__main__&#34;:
    data_dir_path = sys.argv[1]
    data_dir_tester = DataDirTester(data_dir_path)

    if len(sys.argv) == 3:
        script_path = sys.argv[2]
        data_dir_tester = DataDirTester(data_dir_path, component_script=script_path)

    data_dir_tester.run()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="datadirtest.datadirtest.DataDirTester"><code class="flex name class">
<span>class <span class="ident">DataDirTester</span></span>
<span>(</span><span>data_dir: str = 'C:/Users/esner/Documents/Prace/KBC/datadirtest/tests/functional', component_script: str = 'C:/Users/esner/Documents/Prace/KBC/datadirtest/src/component.py', test_data_dir_class: Type[<a title="datadirtest.datadirtest.TestDataDir" href="#datadirtest.datadirtest.TestDataDir">TestDataDir</a>] = datadirtest.datadirtest.TestDataDir, context_parameters: Union[dict, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Object that executes functional tests of the Keboola Connection components.</p>
<p>The <code><a title="datadirtest.datadirtest.DataDirTester" href="#datadirtest.datadirtest.DataDirTester">DataDirTester</a></code> looks for the <code>component.py</code> script and executes it against the specified source folders,
the <code>component.py</code> should expect the data folder path in the environment variable <code>KBC_DATADIR</code>.</p>
<p>Each test is specified by a folder containing following folder structure:</p>
<ul>
<li><code>source</code> - contains data folder that would be on the input of the component</li>
<li><code>expected</code> - contains data folder that is result of the execution against the <code>source</code> folder.
Include only folder that contain some files, e.g. <code>expected/files/out/file.json</code></li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to directory that holds functional test directories. By default this is</dd>
<dt>./functional</dt>
<dt><strong><code>component_script</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to the component script. By default this is ../src/component.py</dd>
<dt><strong><code>context_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with optional parameters that will be passed to each Test instance.</dd>
<dt>Usefull when overriding the TestDataDirClass to add custom functionality</dt>
<dt><strong><code>test_data_dir_class</code></strong> :&ensp;<code>Type[<a title="datadirtest.datadirtest.TestDataDir" href="#datadirtest.datadirtest.TestDataDir">TestDataDir</a>]</code></dt>
<dd>Class extending datadirtest.TestDataDir class with additional</dd>
</dl>
<p>functionality. It will be used for each test in the suit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataDirTester:
    &#34;&#34;&#34;
        Object that executes functional tests of the Keboola Connection components.

        The `DataDirTester` looks for the `component.py` script and executes it against the specified source folders,
        the `component.py` should expect the data folder path in the environment variable `KBC_DATADIR`.

        Each test is specified by a folder containing following folder structure:

        - `source` - contains data folder that would be on the input of the component
        - `expected` - contains data folder that is result of the execution against the `source` folder.
        Include only folder that contain some files, e.g. `expected/files/out/file.json`
    &#34;&#34;&#34;

    def __init__(self, data_dir: str = Path(&#39;./tests/functional&#39;).absolute().as_posix(),
                 component_script: str = Path(&#39;./src/component.py&#39;).absolute().as_posix(),
                 test_data_dir_class: Type[TestDataDir] = TestDataDir,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;

        Args:
            data_dir (str): file_path to directory that holds functional test directories. By default this is
            ./functional
            component_script (str): file_path to the component script. By default this is ../src/component.py
            context_parameters (dict): dictionary with optional parameters that will be passed to each Test instance.
            Usefull when overriding the TestDataDirClass to add custom functionality
            test_data_dir_class (Type[TestDataDir]): Class extending datadirtest.TestDataDir class with additional
            functionality. It will be used for each test in the suit.


        &#34;&#34;&#34;
        self._data_dir = data_dir
        self._component_script = component_script
        self._context_parameters = context_parameters or {}
        self.__test_class = test_data_dir_class

    def run(self):
        &#34;&#34;&#34;
            Runs functional tests specified in the provided folder based on the source/expected datadirs.
        &#34;&#34;&#34;
        testing_dirs = self._get_testing_dirs(self._data_dir)
        dir_test_suite = self._build_dir_test_suite(testing_dirs)
        test_runner = unittest.TextTestRunner(verbosity=3)
        result = test_runner.run(dir_test_suite)
        if not result.wasSuccessful():
            raise AssertionError(f&#39;Functional test suite failed. {result.errors}&#39;)

    @staticmethod
    def _get_testing_dirs(data_dir: str) -&gt; List:
        &#34;&#34;&#34;
        Gets directories within a directory that do not start with an underscore

        Args:
            data_dir: directory which holds directories

        Returns:
            list of paths inside directory
        &#34;&#34;&#34;
        return [os.path.join(data_dir, o) for o in os.listdir(data_dir) if
                os.path.isdir(os.path.join(data_dir, o)) and not o.startswith(&#39;_&#39;)]

    def _build_dir_test_suite(self, testing_dirs):
        &#34;&#34;&#34;
        Creates a test suite for a directory, each test is added using addTest to pass through parameters

        Args:
            testing_dirs: directories that holds data for the test

        Returns:
            Unittest Suite containing all functional tests

        &#34;&#34;&#34;
        suite = unittest.TestSuite()
        for testing_dir in testing_dirs:
            suite.addTest(self.__test_class(method_name=&#39;compare_source_and_expected&#39;,
                                            data_dir=testing_dir,
                                            component_script=self._component_script,
                                            context_parameters=self._context_parameters))
        return suite</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="datadirtest.datadirtest.DataDirTester.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs functional tests specified in the provided folder based on the source/expected datadirs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    &#34;&#34;&#34;
        Runs functional tests specified in the provided folder based on the source/expected datadirs.
    &#34;&#34;&#34;
    testing_dirs = self._get_testing_dirs(self._data_dir)
    dir_test_suite = self._build_dir_test_suite(testing_dirs)
    test_runner = unittest.TextTestRunner(verbosity=3)
    result = test_runner.run(dir_test_suite)
    if not result.wasSuccessful():
        raise AssertionError(f&#39;Functional test suite failed. {result.errors}&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir"><code class="flex name class">
<span>class <span class="ident">TestDataDir</span></span>
<span>(</span><span>data_dir: str, component_script: str, method_name: str = 'compare_source_and_expected', context_parameters: Union[dict, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A test class that runs a component script to get a real output of a component and compares the output to the
specified expected output of that component and its configuration</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the testing method to be run</dd>
<dt><strong><code>data_dir</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to directory which holds the component config, source, and expected directories</dd>
<dt><strong><code>component_script</code></strong> :&ensp;<code>str</code></dt>
<dd>file_path to component script that should be run</dd>
<dt><strong><code>context_parameters</code></strong> :&ensp;<code>dict</code></dt>
<dd>Optional context parameters injected from the DirTester runner.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TestDataDir(unittest.TestCase):
    &#34;&#34;&#34;
    A test class that runs a component script to get a real output of a component and compares the output to the
    specified expected output of that component and its configuration
    &#34;&#34;&#34;

    def __init__(self, data_dir: str, component_script: str, method_name: str = &#39;compare_source_and_expected&#39;,
                 context_parameters: Optional[dict] = None):
        &#34;&#34;&#34;
        Args:
            method_name (str): name of the testing method to be run
            data_dir (str): file_path to directory which holds the component config, source, and expected directories
            component_script (str): file_path to component script that should be run
            context_parameters (dict): Optional context parameters injected from the DirTester runner.
        &#34;&#34;&#34;
        super(TestDataDir, self).__init__(methodName=method_name)
        self.component_script = component_script
        self.orig_dir = data_dir
        self.expected_path = path.join(data_dir, &#39;expected&#39;)
        self.context_parameters = context_parameters

    def setUp(self):
        self.data_dir = self._create_temporary_copy()
        self._run_set_up_script()

    def _run_set_up_script(self):
        start_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;set_up.py&#39;)
        if os.path.exists(start_script_path):
            script = self._load_module_at_path(start_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The set_up.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def tearDown(self) -&gt; None:
        self._run_tear_down_script()
        shutil.rmtree(self.data_dir)

    @staticmethod
    def _load_module_at_path(run_script_path):
        spec = importlib.util.spec_from_file_location(&#34;custom_scripts&#34;, run_script_path)
        script = importlib.util.module_from_spec(spec)
        assert isinstance(spec.loader, Loader)
        spec.loader.exec_module(script)
        return script

    def _run_tear_down_script(self):
        end_script_path = os.path.join(self.orig_dir, &#39;source&#39;, &#39;tear_down.py&#39;)
        if os.path.exists(end_script_path):
            script = self._load_module_at_path(end_script_path)
            try:
                script.run(self)
            except AttributeError:
                raise NotImplementedError(
                    &#34;The tear_down.py file was found but it does not implement the run(context) method. Please add the &#34;
                    &#34;implementation&#34;)

    def id(self):
        return path.basename(self.orig_dir)

    def shortDescription(self) -&gt; Optional[str]:
        return path.basename(self.orig_dir)

    def _create_temporary_copy(self):
        temp_dir = tempfile.gettempdir()
        dst_path = path.join(temp_dir, &#39;test_data&#39;)
        if path.exists(dst_path):
            shutil.rmtree(dst_path)

        shutil.copytree(self.orig_dir, dst_path)
        return dst_path

    def run_component(self):
        &#34;&#34;&#34;
        Runs a component script with a specified configuration
        &#34;&#34;&#34;
        source_dir = path.join(self.data_dir, &#34;source&#34;, &#34;data&#34;)
        os.environ[&#34;KBC_DATADIR&#34;] = source_dir
        run_path(self.component_script, run_name=&#39;__main__&#39;)

    def compare_source_and_expected(self):
        &#34;&#34;&#34;
        Executes and compares source and expected directories based on the nested directory structure and files
        within them

        &#34;&#34;&#34;
        logging.info(f&#34;Running {self.component_script} with configuration from {self.data_dir}&#34;)
        self.run_component()

        files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, &#39;expected&#39;)
        files_real_path, tables_real_path = self.get_data_paths(self.data_dir, &#39;source&#39;)

        if path.exists(files_expected_path) or path.exists(files_real_path):
            self.assert_directory_structure_match(files_expected_path, files_real_path)
            self.assert_directory_files_contents_match(files_expected_path, files_real_path)
        if path.exists(tables_expected_path) or path.exists(tables_real_path):
            self.assert_directory_structure_match(tables_expected_path, tables_real_path)
            self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)
        logging.info(&#34;Tests passed successfully &#34;)

    @staticmethod
    def get_data_paths(data_dir: str, dir_type: str):
        &#34;&#34;&#34;
        Uses the Keboola data structure to return paths to files and tables

        Args:
            data_dir: file_path of directory to get file and table paths from
            dir_type: type of directory source or expected

        Returns:
            paths to files and tables
        &#34;&#34;&#34;
        files_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;files&#39;)
        tables_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;tables&#39;)
        return files_expected_path, tables_expected_path

    @staticmethod
    def get_all_files_in_dir(dir_path: str):
        &#34;&#34;&#34;
        Gets all non-hidden files from a directory and its subdirectory

        Args:
            dir_path: file_path of directory to fetch files from

        Returns:
            list of files in the directory
        &#34;&#34;&#34;
        files = []
        for sub_dir, dir_names, file_names in os.walk(dir_path):
            for filename in [f for f in file_names if not f.startswith(&#34;.&#34;)]:
                files.append(os.path.join(sub_dir, filename))
        return files

    def assert_directory_structure_match(self, expected_path: str, real_path: str):
        &#34;&#34;&#34;
        Tests whether directory structures of two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            expected_path: Path holding the directory of expected files
            real_path: Path holding the directory of real/source files
        &#34;&#34;&#34;
        compared_dir = filecmp.dircmp(expected_path, real_path)

        left = [file for file in compared_dir.left_only if not file.startswith(&#39;.&#39;)]
        right = [file for file in compared_dir.right_only if not file.startswith(&#39;.&#39;)]

        self.assertEqual(left, [], f&#34; Files : {left} exists only in expected output and not in actual output&#34;)
        self.assertEqual(right, [], f&#34; Files : {right} exists only in actual output and not in expected output&#34;)

    def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
        &#34;&#34;&#34;
        Tests whether files in two directories are the same.
        If not the error message prints out which files differ in each directory

        Args:
            files_expected_path:  Path holding expected files
            files_real_path: Path holding real/source files
        &#34;&#34;&#34;
        file_paths = self.get_all_files_in_dir(files_expected_path)
        common_files = [file.replace(files_expected_path, &#34;&#34;).strip(&#34;/&#34;).strip(&#39;\\&#39;) for file in file_paths]
        equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
        self.assertEqual(mismatch, [], f&#34; Files : {mismatch} do not match&#34;)
        self.assertEqual(errors, [], f&#34; Files : {errors} could not be compared&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>unittest.case.TestCase</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="datadirtest.datadirtest.TestDataDir.get_all_files_in_dir"><code class="name flex">
<span>def <span class="ident">get_all_files_in_dir</span></span>(<span>dir_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all non-hidden files from a directory and its subdirectory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dir_path</code></strong></dt>
<dd>file_path of directory to fetch files from</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list of files in the directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_all_files_in_dir(dir_path: str):
    &#34;&#34;&#34;
    Gets all non-hidden files from a directory and its subdirectory

    Args:
        dir_path: file_path of directory to fetch files from

    Returns:
        list of files in the directory
    &#34;&#34;&#34;
    files = []
    for sub_dir, dir_names, file_names in os.walk(dir_path):
        for filename in [f for f in file_names if not f.startswith(&#34;.&#34;)]:
            files.append(os.path.join(sub_dir, filename))
    return files</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.get_data_paths"><code class="name flex">
<span>def <span class="ident">get_data_paths</span></span>(<span>data_dir: str, dir_type: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the Keboola data structure to return paths to files and tables</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_dir</code></strong></dt>
<dd>file_path of directory to get file and table paths from</dd>
<dt><strong><code>dir_type</code></strong></dt>
<dd>type of directory source or expected</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>paths to files and tables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_data_paths(data_dir: str, dir_type: str):
    &#34;&#34;&#34;
    Uses the Keboola data structure to return paths to files and tables

    Args:
        data_dir: file_path of directory to get file and table paths from
        dir_type: type of directory source or expected

    Returns:
        paths to files and tables
    &#34;&#34;&#34;
    files_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;files&#39;)
    tables_expected_path = path.join(data_dir, dir_type, &#39;data&#39;, &#39;out&#39;, &#39;tables&#39;)
    return files_expected_path, tables_expected_path</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="datadirtest.datadirtest.TestDataDir.assert_directory_files_contents_match"><code class="name flex">
<span>def <span class="ident">assert_directory_files_contents_match</span></span>(<span>self, files_expected_path: str, files_real_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether files in two directories are the same.
If not the error message prints out which files differ in each directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>files_expected_path</code></strong></dt>
<dd>Path holding expected files</dd>
<dt><strong><code>files_real_path</code></strong></dt>
<dd>Path holding real/source files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_directory_files_contents_match(self, files_expected_path: str, files_real_path: str):
    &#34;&#34;&#34;
    Tests whether files in two directories are the same.
    If not the error message prints out which files differ in each directory

    Args:
        files_expected_path:  Path holding expected files
        files_real_path: Path holding real/source files
    &#34;&#34;&#34;
    file_paths = self.get_all_files_in_dir(files_expected_path)
    common_files = [file.replace(files_expected_path, &#34;&#34;).strip(&#34;/&#34;).strip(&#39;\\&#39;) for file in file_paths]
    equal, mismatch, errors = filecmp.cmpfiles(files_expected_path, files_real_path, common_files, shallow=False)
    self.assertEqual(mismatch, [], f&#34; Files : {mismatch} do not match&#34;)
    self.assertEqual(errors, [], f&#34; Files : {errors} could not be compared&#34;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.assert_directory_structure_match"><code class="name flex">
<span>def <span class="ident">assert_directory_structure_match</span></span>(<span>self, expected_path: str, real_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether directory structures of two directories are the same.
If not the error message prints out which files differ in each directory</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expected_path</code></strong></dt>
<dd>Path holding the directory of expected files</dd>
<dt><strong><code>real_path</code></strong></dt>
<dd>Path holding the directory of real/source files</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_directory_structure_match(self, expected_path: str, real_path: str):
    &#34;&#34;&#34;
    Tests whether directory structures of two directories are the same.
    If not the error message prints out which files differ in each directory

    Args:
        expected_path: Path holding the directory of expected files
        real_path: Path holding the directory of real/source files
    &#34;&#34;&#34;
    compared_dir = filecmp.dircmp(expected_path, real_path)

    left = [file for file in compared_dir.left_only if not file.startswith(&#39;.&#39;)]
    right = [file for file in compared_dir.right_only if not file.startswith(&#39;.&#39;)]

    self.assertEqual(left, [], f&#34; Files : {left} exists only in expected output and not in actual output&#34;)
    self.assertEqual(right, [], f&#34; Files : {right} exists only in actual output and not in expected output&#34;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.compare_source_and_expected"><code class="name flex">
<span>def <span class="ident">compare_source_and_expected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes and compares source and expected directories based on the nested directory structure and files
within them</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_source_and_expected(self):
    &#34;&#34;&#34;
    Executes and compares source and expected directories based on the nested directory structure and files
    within them

    &#34;&#34;&#34;
    logging.info(f&#34;Running {self.component_script} with configuration from {self.data_dir}&#34;)
    self.run_component()

    files_expected_path, tables_expected_path = self.get_data_paths(self.data_dir, &#39;expected&#39;)
    files_real_path, tables_real_path = self.get_data_paths(self.data_dir, &#39;source&#39;)

    if path.exists(files_expected_path) or path.exists(files_real_path):
        self.assert_directory_structure_match(files_expected_path, files_real_path)
        self.assert_directory_files_contents_match(files_expected_path, files_real_path)
    if path.exists(tables_expected_path) or path.exists(tables_real_path):
        self.assert_directory_structure_match(tables_expected_path, tables_real_path)
        self.assert_directory_files_contents_match(tables_expected_path, tables_real_path)
    logging.info(&#34;Tests passed successfully &#34;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id(self):
    return path.basename(self.orig_dir)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.run_component"><code class="name flex">
<span>def <span class="ident">run_component</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a component script with a specified configuration</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_component(self):
    &#34;&#34;&#34;
    Runs a component script with a specified configuration
    &#34;&#34;&#34;
    source_dir = path.join(self.data_dir, &#34;source&#34;, &#34;data&#34;)
    os.environ[&#34;KBC_DATADIR&#34;] = source_dir
    run_path(self.component_script, run_name=&#39;__main__&#39;)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.setUp"><code class="name flex">
<span>def <span class="ident">setUp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for setting up the test fixture before exercising it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setUp(self):
    self.data_dir = self._create_temporary_copy()
    self._run_set_up_script()</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.shortDescription"><code class="name flex">
<span>def <span class="ident">shortDescription</span></span>(<span>self) ‑> Union[str, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a one-line description of the test, or None if no
description has been provided.</p>
<p>The default implementation of this method returns the first line of
the specified test method's docstring.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shortDescription(self) -&gt; Optional[str]:
    return path.basename(self.orig_dir)</code></pre>
</details>
</dd>
<dt id="datadirtest.datadirtest.TestDataDir.tearDown"><code class="name flex">
<span>def <span class="ident">tearDown</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method for deconstructing the test fixture after testing it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tearDown(self) -&gt; None:
    self._run_tear_down_script()
    shutil.rmtree(self.data_dir)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="datadirtest" href="index.html">datadirtest</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="datadirtest.datadirtest.DataDirTester" href="#datadirtest.datadirtest.DataDirTester">DataDirTester</a></code></h4>
<ul class="">
<li><code><a title="datadirtest.datadirtest.DataDirTester.run" href="#datadirtest.datadirtest.DataDirTester.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="datadirtest.datadirtest.TestDataDir" href="#datadirtest.datadirtest.TestDataDir">TestDataDir</a></code></h4>
<ul class="">
<li><code><a title="datadirtest.datadirtest.TestDataDir.assert_directory_files_contents_match" href="#datadirtest.datadirtest.TestDataDir.assert_directory_files_contents_match">assert_directory_files_contents_match</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.assert_directory_structure_match" href="#datadirtest.datadirtest.TestDataDir.assert_directory_structure_match">assert_directory_structure_match</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.compare_source_and_expected" href="#datadirtest.datadirtest.TestDataDir.compare_source_and_expected">compare_source_and_expected</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.get_all_files_in_dir" href="#datadirtest.datadirtest.TestDataDir.get_all_files_in_dir">get_all_files_in_dir</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.get_data_paths" href="#datadirtest.datadirtest.TestDataDir.get_data_paths">get_data_paths</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.id" href="#datadirtest.datadirtest.TestDataDir.id">id</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.run_component" href="#datadirtest.datadirtest.TestDataDir.run_component">run_component</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.setUp" href="#datadirtest.datadirtest.TestDataDir.setUp">setUp</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.shortDescription" href="#datadirtest.datadirtest.TestDataDir.shortDescription">shortDescription</a></code></li>
<li><code><a title="datadirtest.datadirtest.TestDataDir.tearDown" href="#datadirtest.datadirtest.TestDataDir.tearDown">tearDown</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>